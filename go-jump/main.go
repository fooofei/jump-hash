package main

import (
	"fmt"
	"io"
	"os"
)


type Status int
const (
	On Status = iota
	Off
)

func (s Status)String() string{
	switch s {
	case On:
		return "On"
	case Off:
		return "Off"
	default:
		return "Ukn"
	}
}

type item struct {
	Index int32 // the index of in raw array
	Status Status
}

//Hash get result by hash
// numBuckets >=1
// return one value of [0, numBuckets)
func Hash(key uint64, numBuckets int) int32 {

	var b int64 = -1
	var j int64

	for j < int64(numBuckets) {
		b = j
		key = key*2862933555777941757 + 1
		j = int64(float64(b+1) * (float64(int64(1)<<31) / float64((key>>33)+1)))
	}

	return int32(b)
}


func hashIsConsistent(k uint64, n int) {
	h := Hash(k, n);
	fmt.Printf("hash of %v in %v =%v\n",k,n, h)
}

func testHash1(){
	/*
		hash of 10863919174838991 in 3 =1
		hash of 10863919174838992 in 3 =1
		hash of 10863919174838993 in 3 =0
		hash of 10863919174838994 in 3 =0
		hash of 10863919174838995 in 3 =2
		hash of 10863919174838996 in 3 =1
		hash of 10863919174838997 in 3 =2
	*/

	hashIsConsistent(10863919174838991, 3);
	hashIsConsistent(10863919174838992, 3);
	hashIsConsistent(10863919174838993, 3);
	hashIsConsistent(10863919174838994, 3);
	hashIsConsistent(10863919174838995, 3);
	hashIsConsistent(10863919174838996, 3);
	hashIsConsistent(10863919174838997, 3);
}
func testHash2(){

	/*
		hash of 10863919174838991 in 2 =1
		hash of 10863919174838992 in 2 =1
		hash of 10863919174838993 in 2 =0
		hash of 10863919174838994 in 2 =0
		hash of 10863919174838995 in 2 =0
		hash of 10863919174838996 in 2 =1
		hash of 10863919174838997 in 2 =1

	*/
	hashIsConsistent(10863919174838991, 2);
	hashIsConsistent(10863919174838992, 2);
	hashIsConsistent(10863919174838993, 2);
	hashIsConsistent(10863919174838994, 2);
	hashIsConsistent(10863919174838995, 2);
	hashIsConsistent(10863919174838996, 2);
	hashIsConsistent(10863919174838997, 2);
}

func RHash(key uint64, itemsRaw []*item) int32 {

	items := append(make([]*item,0),itemsRaw...)
	for{
		idx := Hash(key,len(items))
		if items[idx].Status == On {
			return items[idx].Index
		}
		items = append(items[:idx],items[idx+1:]...)
		// from https://nuclear.llnl.gov/CNP/rng/rngman/node4.html
		//key = key*2862933555777941757 + 1
		key +=1 // 够了
		if len(items) <=0 {
			return -1
		}
	}
}

func manyKeysOfRHash(items []*item) {
	var key uint64
	key = 10863919174838991

	loadBalance := make([][]uint64,len(items))

	for idx:=0; idx<100;idx+=1{
		key = key + 1
		h := RHash(key, items)
		if h <0 {
			fmt.Printf("error of h = %v\n", h)
		} else{
			loadBalance[h]= append(loadBalance[h],key)
		}
	}
	detailLBStatus(loadBalance, items, os.Stdout)
}

func detailLBStatus(lb [][]uint64, items []*item, wtr io.Writer) {
	_,_ = fmt.Fprintf(wtr, "load balance status:\n")

	for idx,l := range lb {
		_,_ = fmt.Fprintf(wtr, "  [%v][%v]len= %v", idx,items[idx].Status, len(l))
		for _,b := range l {
			_,_ = fmt.Fprintf(wtr," %v",b)
		}
		_,_ = fmt.Fprintf(wtr,"\n")
	}
}

/**
load balance status:
  [0][On]len= 11 10863919174838999 10863919174839005 10863919174839012 10863919174839018 10863919174839031 10863919174839044 10863919174839057 10863919174839063 10863919174839070 10863919174839076 10863919174839089
  [1][On]len= 10 10863919174838998 10863919174839002 10863919174839010 10863919174839022 10863919174839030 10863919174839034 10863919174839042 10863919174839069 10863919174839073 10863919174839081
  [2][On]len= 10 10863919174839014 10863919174839029 10863919174839036 10863919174839037 10863919174839046 10863919174839066 10863919174839078 10863919174839080 10863919174839085 10863919174839088
  [3][On]len= 10 10863919174838994 10863919174839007 10863919174839017 10863919174839024 10863919174839026 10863919174839028 10863919174839033 10863919174839065 10863919174839068 10863919174839087
  [4][On]len= 9 10863919174839021 10863919174839023 10863919174839035 10863919174839040 10863919174839043 10863919174839047 10863919174839058 10863919174839075 10863919174839084
  [5][On]len= 7 10863919174838997 10863919174839019 10863919174839045 10863919174839052 10863919174839077 10863919174839090 10863919174839091
  [6][On]len= 11 10863919174839001 10863919174839006 10863919174839008 10863919174839009 10863919174839015 10863919174839048 10863919174839051 10863919174839059 10863919174839079 10863919174839082 10863919174839086
  [7][On]len= 7 10863919174838996 10863919174839004 10863919174839020 10863919174839027 10863919174839038 10863919174839053 10863919174839067
  [8][On]len= 14 10863919174838992 10863919174839000 10863919174839003 10863919174839013 10863919174839016 10863919174839032 10863919174839041 10863919174839049 10863919174839054 10863919174839055 10863919174839060 10863919174839062 10863919174839072 10863919174839074
  [9][On]len= 11 10863919174838993 10863919174838995 10863919174839011 10863919174839025 10863919174839039 10863919174839050 10863919174839056 10863919174839061 10863919174839064 10863919174839071 10863919174839083
load balance status:
  [0][Off]len= 0
  [1][On]len= 10 10863919174838998 10863919174839002 10863919174839010 10863919174839022 10863919174839030 10863919174839034 10863919174839042 10863919174839069 10863919174839073 10863919174839081
  [2][On]len= 10 10863919174839014 10863919174839029 10863919174839036 10863919174839037 10863919174839046 10863919174839066 10863919174839078 10863919174839080 10863919174839085 10863919174839088
  [3][On]len= 10 10863919174838994 10863919174839007 10863919174839017 10863919174839024 10863919174839026 10863919174839028 10863919174839033 10863919174839065 10863919174839068 10863919174839087
  [4][On]len= 9 10863919174839021 10863919174839023 10863919174839035 10863919174839040 10863919174839043 10863919174839047 10863919174839058 10863919174839075 10863919174839084
  [5][On]len= 9 10863919174838997 10863919174839019 10863919174839045 10863919174839052 10863919174839057 10863919174839070 10863919174839077 10863919174839090 10863919174839091
  [6][On]len= 15 10863919174839001 10863919174839006 10863919174839008 10863919174839009 10863919174839015 10863919174839018 10863919174839044 10863919174839048 10863919174839051 10863919174839059 10863919174839076 10863919174839079 10863919174839082 10863919174839086 10863919174839089
  [7][On]len= 9 10863919174838996 10863919174839004 10863919174839005 10863919174839020 10863919174839027 10863919174839038 10863919174839053 10863919174839063 10863919174839067
  [8][On]len= 14 10863919174838992 10863919174839000 10863919174839003 10863919174839013 10863919174839016 10863919174839032 10863919174839041 10863919174839049 10863919174839054 10863919174839055 10863919174839060 10863919174839062 10863919174839072 10863919174839074
  [9][On]len= 14 10863919174838993 10863919174838995 10863919174838999 10863919174839011 10863919174839012 10863919174839025 10863919174839031 10863919174839039 10863919174839050 10863919174839056 10863919174839061 10863919174839064 10863919174839071 10863919174839083

when only [0]=Off , the keys in [0] will spread as
10863919174838999:9
10863919174839005:7
10863919174839012:9
10863919174839018:6
10863919174839031:9
10863919174839044:6
10863919174839057:5
10863919174839063:7
10863919174839070:5
10863919174839076:6
10863919174839089:6

 */

func test3(){
	items := make([]*item, 0)

	for idx :=0 ; idx < 10 ; idx +=1 {
		items = append(items, &item{Index:int32(idx),Status:On})
	}

	manyKeysOfRHash(items)

	items[3].Status=Off
	manyKeysOfRHash(items)
}

func main(){



	/**
	如何应对服务器下线呢？
	分两种情况理解，但是按照一种情况处理
	  1 非索引为最后的服务器
	    先按照服务器在线的情况求哈希，若哈希到的服务器是下线的
	    则重新哈希，这时候的哈希是依据在线服务器哈希，
	    一定能哈希到可用服务器，且平均分配 (错误，一定不是平均分配)
	 2 索引为最后的服务器，这就相当于增加服务器的逆操作

	jump hash 无法处理索引对应的服务器变化的情况
	 */

	test3()

}
